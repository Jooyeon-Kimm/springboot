*******************************************************************************
1. 환경 세팅
*******************************************************************************
1-1. Oracle JDK 설치 (java version "19.0.1" 2022-10-18)
1-2. MySQL 5.7 설치  (MySQL5.7.41)
1-3. 쿠키런 폰트 설치
1-4. STS 툴 설치


1-5. 인텔리 J - 키맵 세팅
Eclipse Marketplace - IntelliJ IDEA keymap for Eclipse 0.1
1-6. UTF-8 세팅
1-7. 폰트 세팅

*******************************************************************************
2. 의존성 설정
*******************************************************************************
2-1. Spring Boot DevTools
2-2. Lombok
2-3. Spring Data JPA
2-4. MySQL Driver
2-5. Spring Security
 

2-6. OAuth2 Client - 세팅안함.
직접 카카오 로그인 구현하여 개념잡기
JWT는 APP과 연동할 때 사용할 예정

2-7. 템플릿 엔진
jsp 사용할 예정

2-8. Spring Web
WEB MVC를 사용하여 웹 애플리케이션을 만드는데 필요한 스프링부트의 기본적인 요소를 가짐.
내장형 컨테이너로 톰캣을 기본탑재하고 있다.

2-10. 추가적
<!-- 시큐리티 태그 라이브러리 -->
<dependency>
  <groupId>org.springframework.security</groupId>
  <artifactId>spring-security-taglibs</artifactId>
</dependency>

<!-- JSP 템플릿 엔진 -->
<dependency>
  <groupId>org.apache.tomcat.embed</groupId>
  <artifactId>tomcat-embed-jasper</artifactId>
</dependency>

<!-- JSTL -->
<dependency>
  <groupId>javax.servlet</groupId>
  <artifactId>jstl</artifactId>
</dependency>

*******************************************************************************
3. MySQL 한글 설정 및 연결
*******************************************************************************
3-1. MySQL 한글 설정
my.ini 파일
MySQL 재시작

[client]
default-character-set=utf8

[mysql]
default-character-set=utf8

[mysqld]
collation-server = utf8_unicode_ci
init-connect='SET NAMES utf8'
init_connect='SET collation_connection = utf8_general_ci'
character-set-server=utf8

3-2.한글 설정 확인
show variables like 'c%';
show variables like 'c%';

3-3. 사용자 생성 및 권한 주기 및 DB 생성
-- 유저이름@아이피주소
create user 'joo'@'%' identified by 'joo1234';
-- ON DB이름.테이블명
-- TO 유저이름@아이피주소
GRANT ALL PRIVILEGES ON *.* TO 'joo'@'%';
CREATE DATABASE blog CHARACTER SET utf8 DEFAULT COLLATE utf8_general_ci;
use blog;

3-4. MySQL 프로젝트 연결
src/main/resources/application.yml

spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/blog?serverTimezone=Asia/Seoul
    username: joo
    password: joo1234
*******************************************************************************
4. Git 세팅
*******************************************************************************
4-1. github 로그인
4-2. git 설치

4-3. 내 프로젝트 git 연동
git init
git add .
git commit -m "환경세팅완료 v1"
git remote add origin 주소
git push origin master


*******************************************************************************
5. HTTP1.1 체험하기
*******************************************************************************
5-1. POSTMAN 설치
5-2. HTTP1.1 의 통신 방법 4가지 (요청의 방법)
get : 데이터를 줘! - 데이터베이스에서 SELECT
post : 데이터를 추가해줘 - INSERT
put : 데이터를 수정해줘 - UPDATE
delete : 데이터를 삭제해줘 - DELETE

어떤 데이터를? (what)


5-3. stateless 와 stateful
-- stateful
ex) 채팅
클라이언트가 서버에게 요청을 하고
서버가 클라이언트에게 응답을 할 때
지속적인 요청과 응답이 일어날 수 있도록
클라이언트 포트와 서버 포트가 연결되어 있다.

세션이 만들어졌다
= 데이터를 응답해줄 준비가 되었다.
근거: 인증이 되어 있다.
한 번 인증된 포트는 계속 통신을 하면서
데이터를 막 주고받을 수 있다. (세션 유지)

-- stateless
ex) http
요청과 응답을 하지 않을 때는
연결이 끊어져있다.

한 번 인증을 했어도
세션이 유지되지 않는다.

http: 문서전달을 목적으로 만들어졌지만
요즘은 홈페이지 만들기, 회원가입 하기, 데이터 주고 받기, 동영상 등등
많은 것들을 한다.


5-4. MIME 타입
클라이언트가 서버에게 POST 요청을 한다. (데이터를 추가해달라)
헤더: 데이터를 설명해주는 내용
바디: 데이터

http 통신 방식 2가지:
패킷 스위칭 방식:
데이터를 패킷으로 나누어서 순서대로 전달

 
서킷 스위칭 방식: 
A와 B가 데이터를 교환할 때
데이터를 한 큐에 실어서 전달

장점:
속력이 빠르다.

단점: 
물리적으로 선이 계속 추가가 되어야하니까 비용이 많이 든다



5-5. Controller 생성 및 실습
HttpControllerTest.java 생성
Get 메서드
Post 메서드
Put 메서드
Delete 메서드

5-6. postman에서 http 요청 실습


*******************************************************************************
6. lombok 세팅 및 사용하기
*******************************************************************************
메이븐이 관리하는 라이브러리들이 있는 곳 주소:
C:\Users\사용자이름\.m2\repository

lombok-1.18.24.jar 위치:
C:\Users\joooo\.m2\repository\org\projectlombok\lombok\1.18.24

lombok-1.18.24.jar을 실행해서
Tool이 lombok을 인식할 수 있도록 빌드하기

lombok 위치에서 우클릭 > Git Bash Here:
java -jar lombok-1.18.24.jar

C:\Util\sts-4.17.1.RELEASE 로 이동하기
SpringToolSuite4.exe 선택하기 (SELECT)


@Getter
@Setter

//Getter, Setter
@Data

//final 형 변수에 대한 생성자 만들어준다
@RequiredArgsConstructor

//생성자
@AllArgsConstructor

//빈 생성자 (final 형에서 사용 불가)
@NoArgsConstructor

@Builder
*******************************************************************************
7. yml 설정하기
*******************************************************************************
1. yaml 이란
설명: https://www.inflearn.com/questions/16184


xml 파일: 메타데이터 아래에
key가 닫힌 형태로 있어서
데이터 크기가 크다

jason 파일:
닫힌 형태는 없어서
xml 파일보다는 크기가 작다.
key 값에 쌍 따옴표 (" ")가 있다.

yml 파일:
key와 value 사이에 space( ) 가 꼭 있어야 한다 (규칙)
yml 파일은 중괄호 없이
들여쓰기, 스페이스 두 칸 (  ).
yml 파일은 jason 파일보다 가볍다.



2. yml 설정
web.xml, root-context.xml, servlet-context.xml의 합본

root-context.xml 파일에는
싱글톤으로 관리할 수 있는 것들
객체가 하나만 있으면 되는 것들
한 번만 new 하면 되는 것들

servlet-context.xml
지속적으로 계속 new해서 사용하는 것들


결론: 스프링에서는 위 3가지를 구분하지 않고
application.yml 파일에 모든 설정을 하면 된다.

application.yml
server:
  port: 8000
  servlet:
    context-path: /blog
    encoding:
      charset: UTF-8
      enabled: true
      force: true
    
spring:
  mvc:
    view:
      prefix: /WEB-INF/views/
      suffix: .jsp
      
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/blog?serverTimezone=Asia/Seoul
    username: cos
    password: cos1234
    
  jpa:
    open-in-view: true
    hibernate:
      ddl-auto: create
      naming:
        physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
      use-new-id-generator-mappings: false
    show-sql: true
    properties:
      hibernate.format_sql: true

  jackson:
    serialization:
      fail-on-empty-beans: false

(1) jasper
.jsp 경로를 설정한 이유는 스프링 부트는 
기본적으로 jsp사용이 권장하기 않기 때문에
 timeleaf 같은 다른 템플릿 엔진을 사용해야 한다. 
하지만  jsp를 사용하기 위해서는 
해당 구조로 폴더 구성을 한 뒤 세팅하여야 한다. (jasper)

 

(2) com.mysql.cj.jdbc.Driver
datasource 의 mysql 드라이버에 cj가 들어간 이유는 
mysql 6점대 이상 버전부터는 해당 드라이버를 사용하고 
그 이전 드라이버는 cj가 없는 com.mysql.jdbc.Driver를 사용한다.

 

(3) open-in-view
org.springframework.orm.hibernate3.support.OpenSessionInViewFilter 
클래스 영속성을 프리젠테이션 계층까지 가져간다. 
트랜잭션은 Service계층에서 종료된다. 
Transaction이 종료된 후에도 Controller의 Session이 close되지 않았기 때문에, 
영속 객체는 Persistence 상태를 유지할 수 있으며, 
따라서 프록시 객체에 대한 Lazy Loading을 수행할 수 있게 된다.

버전 2.0부터 스프링 부트는 기본적으로
 OSIV가 활성화되어있을 때 경고를 발행하므로 
프로덕션 시스템에 영향을 주기 전에 이 문제를 발견 할 수 있다.

서블릿 필터에서 Session 을 오픈하고 트랜잭션을 시작하던 
전통적인 방식의 OPEN SESSION IN VIEW 패턴과 달리 
SpringMVC 에서 제공하는 OpenSessionInViewFilter 는 
필터 내에서 Session 은 오픈하지만 
트랜잭션은 시작하지 않는다. 
따라서 서블릿 필터 안에서는 
커넥션 풀로부터 JDBC 커넥션을 얻을 필요가 없다.

hibernate.enable_lazy_load_no_trans: true  
OSIV를 활성화 하였다면 위에 옵션을 필요 없다. 
그리고 OSIV는 스프링부트가 디폴트로 활성화하고 있는 옵션이다. 
경고를 제거하기 위해 명확하게 적어준 것 뿐!!


(4) ddl-auto
create - 서버 시작시마다 DB초기화
update - 수정사항만 DB에 반영
none - DB에 아무런 반영을 하지 않음.

​

(5) physical-strategy
org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
엔티티를 만들 때 변수명 그대로 DB에 필드를 만들어 준다.
org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy
엔티티를 만들 때 변수명에 언더스코어를 붙여준다. 예) createDate -> create_date

(6) show-sql: true

(7) use-new-id-generator-mappings: false
use-new-id-generator-mappings 는 mysql로 말하면 
auto_increment 오라클로 말하면 시퀀스를 어떤식으로 사용할지 방식을 결정하는 것인데 
false를 하면 jpa가 사용하는 기본 넘버링 전략을 따라가지 않는다는 뜻이고 
true를 하면 기본 넘버링 전략을 따라간다는 뜻이다.

 

(8) jackson:
          serialization:
              fail-on-empty-beans: false


Lazy-loading으로 인해 empty-beans이 생길 수 있다. 
너그럽게 빈 객체를 허락해주는 옵션이다.
​
*******************************************************************************
8. 테이블 생성하기
*******************************************************************************

1. Blog 테이블 만들기 (User, Board, Reply) 
 

2. 연관관계 만들기
@ManyToOne
@OneToMany
@OneToOne
@ManyToMany
ManyToMany는 사용하지 않는다. 
그 이유는 서로의 primary key로만 중간 테이블을 생성해주는데, 
날짜나 시간 다른 필드들이 필요할 수 있기 때문에, 
내가 중간 테이블을 직접만들고 
@OneToMany, @OneToMany를 사용한다.

https://ict-nroo.tistory.com/127



3. 더미 데이터 insert
@DynamicInsert insert할때 null 인 필드 제외

4. 더미 데이터 select 및 응답
User user = userRepository.findById(id).orElseThrow(new Supplier<IllegalArgumentException>() {
			@Override
			public IllegalArgumentException get() {
				return new IllegalArgumentException("해당 사용자가 없습니다.");
			}
		});
@PageableDefault(size=2, sort="id", direction = Sort.Direction.DESC) Pageable pageable
 

5. 더미 데이터 update
https://ict-nroo.tistory.com/130

6. 더미 데이터 delete
 
7. 무한 참조 방지하기
(1) Entity로 받고 Json직렬화 하기 전에 DTO 생성후 복사하기
BeanUtils.copyProperties(A,B) 
(2) 처음부터 DTO로 DB에서 받기
(3) @JsonIgnore
(4) @JsonIgnoreProperties({"board"})
(5) @JsonBackReference @JsonManagedReference 

 

참고 
https://dublin-java.tistory.com/32 


8. 연관관계의 주인 = FK를 가진 오브젝트
자바 프로그램 > JPA > DB
JPA: Board (유저정보, ID = 1)
DB: Join문, user + board


9. Json
프랑스인이 한국인에게 불어로 안녕이라고 정보를 보냈다.
한국인은 이를 해석하기 위해 프랑스어를 공부한다.

일본인이 한국인에게 일본어로 안녕이라고 정보를 보냈다.
한국인은 이를 해석하기 위해 일본어를 공부한다.

독일인이 한국인에게 독일어로 안녕이라고 정보를 보냈다.
한국인은 이를 해석하기 위해 독일어를 공부한다.


너무 비효율적이다.
한국인 1명이 3가지 언어를 모두 공부해야 하다니.

그래서 한국인이 제안했다.
프랑스인아, 일본인아, 독일인아
너네들이 한국어를 공부를 해서
한국어로 메세지를 보내.

끝.

그런데 메세지를 받는 사람이
한국인에서 미국인으로 바뀌었다면
프랑스인, 일본인, 독일인은 비상이다.
다시 영어를 배워야하는 상황이 온 것이다.

이도 비효율적이므로
각 나라 사람들 사이에 공용어를 지정하기로 했다.
모두가 다같이 같은 언어를 공부한다.

프로토콜 (약속) : 
모든 사람들은 데이터를 전송할 때
공용어로 번역하고
모든 사람들은 데이터에 응답할 때
영어를 자기나라 언어로 번역한다.


자바 오브젝트를 JSON 데이터 (데이터 통신을 위한 중간 데이터, 공용어)로 변환해서
파이썬 오브젝트로 전송한다.

통신: 
응답 (response) : 자바 오브젝트를 json데이터로 바꿔서 전송
요청 (request)   : jason데이터를 자바 오브젝트로 바꿔서 전송 

Controller에서 외부에서 request가 올 때
실어나르는 Body데이터를 전부 JSON으로 받는다.
즉, MIME 타입이 JSON이라는 말이다.



​
*******************************************************************************
* 영속성 컨텍스트와 더티체킹
*******************************************************************************

더티체킹(Dirty Checking)이란 상태 변경 검사이다.

JPA에서는 트랜잭션이 끝나는 시점에 변화가 있는 
모든 엔티티 객체를 데이터베이스 반영한다.

그렇기 때문에 값을 변경한 뒤 save 하지 않더라도 
DB에 반영되는 것이다.

이러한 상태 변경 검사의 대상은 
영속성 컨텍스트가 관리하는 엔티티에만 적용된다. (준영속, 비영속된 객체X)

더티체킹(Dirty Checking) 원리:
    · 영속성 컨텍스트란 서버와 DB사이에 존재한다.
    · JPA는 엔티티를 영속성 컨텍스트에 보관할 때, 최초 상태를 복사해서 저장해둔다.(일종의 스냅샷)
    · 트랜잭션이 끝나고 flush할 때 스냅샷과 현재 엔티티를 비교해 변경된 엔티티를 찾아낸다.
    · JPA는 변경된 엔티티를 DB단에 반영하여 한번에 쿼리문을 날려준다.

더티체킹: 찌꺼기 체크해서 날리는 것


*******************************************************************************
9. Json 데이터로 통신하기
*******************************************************************************
1. Get요청 ( select )
주소에 데이터를 담아 보낸다. 데이터 형태는 key=value
http://localhost:8000/blog/user?username=ssar
특징 : body로 데이터를 담아 보내지 않는다.
 

2. Post, Put, Delete 요청 ( 데이터를 변경 )
데이터를 담아 보내야 할 것이 많음
username, password, email, address, gender, createDate
form 태그 method = 'Post'
form 태그 -> get 요청, post 요청 (key = value)
자바스크립트로 요청을 해야 한다

A는 form 태그를 사용하고 
B는 자바스크립트 사용하면
프로그램 로직이 통일이 안 된다

통일 : 자바스크립트로 ajax 요청 + 데이터는 json으로 통일 ( 사용 O )
form:form 태그 -> post 요청, put 요청, delete 요청, get 요청 가능 ( 사용 X )

Body에 데이터를 담아 보낸다
데이터 형태는 json으로 통일하는 것이 좋다.

 

3. 스프링 컨트롤러의 파싱 전략 1
스프링 컨트롤러는 key=value 데이터를 자동으로 파싱하여 변수에 담아준다.

가령 get요청은 key=value이고 
post요청중에 x-www-form-urlencoded (form태그를 만들어서 데이터 전송) 시에도 
key=value 이기 때문에 이러한 데이터는 
아래와 같이 함수의 파라메터로 받을 수 있다.

PostMapping("/home")
public String home(String username, String email){
	
    return "home";
}


4. 스프링 컨트롤러의 파싱 전략 2
스프링은 key=value 형태의 데이터를 
오브젝트로 파싱해서 받아주는 역할도 한다.

** 이때 주의 할점은 setter가 없으면 
key=value 데이터를 스프링이 파싱해서 넣어주지 못한다.

class User {
	private String username;
    private String password;
    
    public String getUsername(){
    	return username;
    }
    
    public String getPassword(){
    	return password;
    }
    
    public void setUsername(String username){
    	this.username = username;
    }
    
    public void setPassword(String password){
    	this.password = password;
    }
    
}
PostMapping("/home")
public String home(User user){
	
    return "home";
}


5. key=value가 아닌 데이터는 어떻게 파싱할까?
json 데이터나 일반 text데이터는 스프링 컨트롤러에서 받기 위해서는 
@RequestBody 어노테이션이 필요하다.

** 기본전략이 스프링 컨트롤러는 key=value 데이터를 파싱해서 받아주는 일을 하는데 
다른 형태의 데이터 가령 json 같은 데이터는 아래와 같이 생겼다.

{
    "username":"ssar",
    "password":"1234"
}

이런 데이터는 스프링이 파싱해서 오브젝트로 받지 못한다. 
그래서 @RequestBody 어노테이션을 붙이면 
MessageConverter 클래스를 구현한 Jackson 라이브러리가 발동하면서 
json 데이터를 자바 오브젝트로 파싱하여 받아준다.

PostMapping("/home")
public String home(@RequestBody User user){
	
    return "home";
}


6. form 태그로 json데이터 요청방법
key=value 데이터가 아니라 json데이터를 어떻게 전송할 수 있을까?

join.jsp
<div class="container">

	<form>
		<div class="form-group">
			<label for="username">유저네임</label> 
			<input type="text" id="username">
		</div>
		<div class="form-group">
			<label for="password">패스워드</label> 
			<input type="password" id="password">
		</div>
		
		<div class="form-group">
			<label for="email">이메일</label> 
			<input type="email" id="email">
		</div>
	</form>
	
	<button id="join--submit" class="btn btn-primary">회원가입</button>

</div>

<script src="/js/join.js"></script>
join.js

<script>
$('#join--submit').on('click', function() {
	var data = {
		username : $('#username').val(),
		password : $('#password').val(),
		email : $('#email').val()
	};

	$.ajax({
		type : 'POST',
		url : '/user/join',
		data : JSON.stringify(data),
		contentType : 'application/json; charset=utf-8',
		dataType : 'json'
	}).done(function(r) {
		if (r.statusCode == 200) {
			console.log(r);
			alert('회원가입 성공');
			location.href = '/user/login';
		} else {
			if (r.msg == '아이디중복') {
				console.log(r);
				alert('아이디가 중복되었습니다.');
			} else {
				console.log(r);
				alert('회원가입 실패');
			}
		}
	}).fail(function(r) {
		var message = JSON.parse(r.responseText);
		console.log((message));
		alert('서버 오류');
	});
});
</script>

*******************************************************************************
10. 화면구현
*******************************************************************************
w3schools.com > bootstrap4
또는 material css

직접 CSS, HTML 사용해서 구현할 수 있지만
부트스트랩을 이용하면
굉장히 간단하게 웹사이트를 구현할 수 있다.

0. NavBar
Collapsing The Navigation Bar

1. 메뉴와 푸터
1-1. 
BS4 Basic Template > Demo > Footer 우클릭 > 검사
> Elements에서 해당 코드 복사 > 우클릭 > Copy > Copy Element

<div class="jumbotron text-center" style="margin-bottom:0">
  <p>Footer</p>
</div>

1-2.
BS4 Cards > 코드 복사 후 추가

2. 회원가입 화면
script 태그는 body와 가깝게
자바스크립트 인터프리터: 한 줄 한 줄 위에서 아래로 순서대로 실행


3. 로그인 화면
BS4 Forms > Bootstrap 4 Stacked Form

4. 글 목록 화면(메인화면)

5. 회원 수정 화면

6. 글 상세보기 화면
7. 글 수정 화면



 *******************************************************************************
11. 화면구현
*******************************************************************************